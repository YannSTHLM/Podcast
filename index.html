<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Podcasts</title>
    
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="theme-color" content="#2c3e50">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Podcasts">
    <link rel="apple-touch-icon" href="/assets/icons/apple-touch-icon.svg">
    <link rel="icon" type="image/png" href="/assets/icons/icon-192.svg">
    
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Crect fill='%233498db' width='128' height='128' rx='24'/%3E%3Cpath fill='%23ffffff' d='M64 20c-22.09 0-40 17.91-40 40v32a12 12 0 0 0 12 12h4a8 8 0 0 0 8-8V68a8 8 0 0 0-8-8h-4a12 12 0 0 0-12 12V60c0-19.88 16.12-36 36-36s36 16.12 36 36v12a12 12 0 0 0-12-12h-4a8 8 0 0 0-8 8v28a8 8 0 0 0 8 8h4a12 12 0 0 0 12-12V60c0-22.09-17.91-40-40-40z'/%3E%3C/svg%3E">
    
    <style>
        :root {
            /* Light Theme Defaults */
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --background-color: #ecf0f1;
            --card-background: #ffffff;
            --text-color: #34495e;
            --text-secondary: #7f8c8d;
            --border-color: #d6dce2;
            --input-bg: #ffffff;
            --hover-color: #f7f9fb;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --modal-overlay: rgba(0,0,0,0.5);
            --shadow: rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] {
            /* Dark Theme Overrides */
            --primary-color: #ecf0f1;
            --secondary-color: #5dade2;
            --background-color: #1a1a1a;
            --card-background: #2d2d2d;
            --text-color: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border-color: #404040;
            --input-bg: #333333;
            --hover-color: #383838;
            --modal-overlay: rgba(0,0,0,0.8);
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * { box-sizing: border-box; transition: background-color 0.3s ease, color 0.3s ease; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
            -webkit-tap-highlight-color: transparent;
        }

        .container { max-width: 1024px; width: 100%; position: relative; padding-bottom: 80px; }

        /* Header & Theme Toggle */
        header { text-align: center; margin-bottom: 30px; color: var(--primary-color); position: relative; }
        header h1 { margin: 0; font-size: clamp(2rem, 3vw, 2.75rem); }
        header p { margin: 8px 0 0 0; font-size: clamp(1rem, 2vw, 1.25rem); color: var(--secondary-color); }
        .last-updated { margin-top: 6px; font-size: 0.85rem; color: var(--text-secondary); }

        .theme-toggle {
            position: absolute; top: 0; right: 0;
            background: none; border: none; cursor: pointer; font-size: 1.5rem;
            color: var(--text-color); padding: 5px; border-radius: 50%;
        }
        .theme-toggle:hover { background-color: var(--hover-color); }

        main { display: flex; flex-direction: column; gap: 24px; }

        /* Player */
        #player-section {
            background-color: var(--card-background);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 8px 24px var(--shadow);
            border: 1px solid var(--border-color);
            position: sticky; top: 20px; z-index: 90;
        }
        #now-playing h2 { margin: 0; color: var(--primary-color); font-size: 1.5rem; }
        #now-playing-description { margin: 10px 0 8px; font-size: 1rem; color: var(--text-secondary); }
        .now-playing-meta { margin: 0; font-size: 0.9rem; color: var(--text-secondary); }
        audio { width: 100%; margin-top: 18px; border-radius: 6px; background-color: #f1f3f5; }
        [data-theme="dark"] audio { filter: invert(0.9); } 

        /* Status */
        #status-banner {
            display: flex; align-items: center; gap: 12px; padding: 14px 18px;
            border-radius: 10px; border: 1px solid transparent;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
        }
        .status-banner--hidden { display: none !important; }
        .status-banner--info { background-color: #d1ecf1; color: #0c5460; border-color: #bee5eb; }
        .status-banner--success { background-color: #d4edda; color: #155724; border-color: #c3e6cb; }
        .status-banner--warning { background-color: #fff3cd; color: #856404; border-color: #ffe8a1; }
        .status-banner--error { background-color: #f8d7da; color: #721c24; border-color: #f5c6cb; }

        /* Filters */
        .filter-bar {
            display: flex; flex-wrap: wrap; gap: 16px; align-items: flex-end;
            background-color: var(--card-background);
            border: 1px solid var(--border-color);
            border-radius: 12px; padding: 16px 20px;
            box-shadow: 0 6px 20px var(--shadow);
        }
        .filter-group { display: flex; flex-direction: column; gap: 6px; flex: 1 1 200px; }
        .filter-bar label { color: var(--text-color); font-size: 0.9rem; font-weight: 500; }
        .filter-bar input, .filter-bar select {
            padding: 10px 12px; border-radius: 8px; border: 1px solid var(--border-color);
            font-size: 0.95rem; width: 100%;
            background-color: var(--input-bg); color: var(--text-color);
        }

        .results-meta { font-size: 0.9rem; color: var(--text-secondary); text-align: right; margin-top: -10px; }

        /* Episodes */
        .episode-item {
            background-color: var(--card-background);
            border-radius: 12px; padding: 20px;
            display: flex; flex-direction: column; gap: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px var(--shadow);
            margin-bottom: 16px;
            transition: transform 0.2s;
        }
        .episode-item:hover { transform: translateY(-2px); box-shadow: 0 8px 16px rgba(0,0,0,0.15); }
        
        .episode-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 15px; }
        .episode-info { flex: 1; }
        
        .episode-meta-badges { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 6px; }
        .badge { 
            font-size: 0.75rem; background: var(--hover-color); color: var(--text-secondary); 
            padding: 2px 8px; border-radius: 12px; border: 1px solid var(--border-color); white-space: nowrap;
        }
        
        .episode-title { margin: 4px 0; color: var(--primary-color); font-size: 1.25rem; }
        .podcast-name { font-size: 0.85rem; color: var(--text-secondary); font-weight: 500; }
        
        .episode-description { color: var(--text-color); line-height: 1.5; font-size: 0.95rem; margin-top: 8px; opacity: 0.9; }
        
        /* Show Notes */
        .full-notes { display: none; margin-top: 12px; padding-top: 12px; border-top: 1px dashed var(--border-color); font-size: 0.9rem; color: var(--text-color); }
        .full-notes.active { display: block; }
        .full-notes img { max-width: 100%; height: auto; border-radius: 8px; margin: 10px 0; }
        .full-notes a { color: var(--secondary-color); }
        .toggle-notes { 
            background: none; border: none; padding: 0; color: var(--secondary-color); 
            font-size: 0.85rem; cursor: pointer; text-decoration: underline; margin-top: 6px;
        }

        /* Buttons */
        .action-row { display: flex; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .btn {
            border: none; border-radius: 8px; padding: 10px 20px; 
            font-size: 0.95rem; cursor: pointer; text-decoration: none;
            display: inline-flex; align-items: center; justify-content: center;
            transition: opacity 0.2s;
        }
        .btn:hover { opacity: 0.9; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-play { background-color: var(--secondary-color); color: #fff; font-weight: 600; }
        .btn-download { 
            background-color: var(--card-background); color: var(--text-color); border: 1px solid var(--border-color); 
        }
        .btn-download:hover { background-color: var(--hover-color); }
        
        .btn-secondary {
            background-color: transparent; color: var(--primary-color); border: 1px solid var(--primary-color);
        }
        .btn-secondary:hover { background-color: var(--primary-color); color: #fff; }

        .btn-manage { background-color: var(--primary-color); color: var(--card-background); margin-top: 23px; width: 100%; }

        /* Modal */
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--modal-overlay); z-index: 1000;
            display: none; justify-content: center; align-items: center;
            padding: 20px;
        }
        .modal-overlay.active { display: flex; }
        
        .modal-content {
            background: var(--card-background); width: 100%; max-width: 700px; height: 85vh;
            border-radius: 12px; display: flex; flex-direction: column;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5); border: 1px solid var(--border-color);
        }
        
        .modal-header {
            padding: 15px 20px; border-bottom: 1px solid var(--border-color);
            display: flex; justify-content: space-between; align-items: center;
            background: var(--hover-color); border-radius: 12px 12px 0 0;
        }
        .modal-header h2 { margin: 0; font-size: 1.25rem; color: var(--text-color); }
        .close-btn { background: none; border: none; color: var(--text-color); font-size: 1.5rem; cursor: pointer; }
        
        .modal-body { padding: 20px; overflow-y: auto; flex: 1; display: flex; flex-direction: column; gap: 20px; color: var(--text-color); }
        
        .section-title { font-size: 0.85rem; text-transform: uppercase; color: var(--text-secondary); font-weight: 700; margin-bottom: 8px; letter-spacing: 0.5px; }
        .search-box { display: flex; gap: 10px; }
        .search-box input { flex: 1; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color); }

        /* Directory Results */
        .directory-results {
            display: flex; flex-direction: column; gap: 8px; max-height: 250px; overflow-y: auto;
            border: 1px solid var(--border-color); padding: 8px; border-radius: 8px; background: var(--hover-color);
        }
        .directory-item {
            display: flex; align-items: center; gap: 12px; padding: 8px; background: var(--card-background);
            border: 1px solid var(--border-color); border-radius: 6px;
        }
        .directory-item img { width: 40px; height: 40px; border-radius: 4px; object-fit: cover; }
        .directory-info { flex: 1; overflow: hidden; }
        .directory-title { font-weight: 600; font-size: 0.9rem; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-color); }
        .directory-author { font-size: 0.75rem; color: var(--text-secondary); }
        .btn-add-feed { background: var(--success-color); color: white; border: none; padding: 5px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85rem; }

        /* Feed List */
        .feed-list-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px; border-bottom: 1px solid var(--border-color); gap: 10px;
        }
        .feed-url { font-size: 0.75rem; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .feed-title { font-weight: 500; font-size: 0.95rem; color: var(--text-color); }
        
        .btn-delete { background: var(--error-color); color: white; padding: 6px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; border: none; }

        .modal-footer { 
            padding: 15px 20px; background: var(--hover-color); 
            border-top: 1px solid var(--border-color); 
            display: flex; justify-content: space-between; border-radius: 0 0 12px 12px; 
        }

        .loading-message { text-align: center; color: var(--text-secondary); padding: 40px; }

        .spinner {
            display:inline-block; width:12px; height:12px; border:2px solid rgba(0,0,0,0.1);
            border-top-color: var(--secondary-color); border-radius:50%; animation: spin 0.9s linear infinite; margin-right:8px; vertical-align:middle;
        }
        @media (max-width: 600px) {
            .action-row { width: 100%; }
            .btn { flex: 1; }
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .error-message { 
            text-align: center; color: var(--error-color); padding: 20px; 
            background: rgba(231, 76, 60, 0.1); border-radius: 8px; border: 1px solid var(--error-color);
            margin: 20px 0;
        }

        @media (max-width: 600px) {
            .action-row { width: 100%; }
            .btn { flex: 1; }
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <button class="theme-toggle" id="theme-toggle" title="Toggle Dark Mode">üåô</button>
        <h1>Podcasts</h1>
        <p>Curated episodes from around the web</p>
        <div id="status-banner" class="status-banner--hidden" style="margin: 10px 0; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; text-align: center;">
            <span id="status-text"></span>
        </div>
        <div style="display:flex; gap:8px; align-items:center; justify-content:center; margin-top:6px; flex-wrap: wrap;">
            <div class="last-updated" id="last-updated"></div>
            <div id="online-status" title="Network status" style="font-size:0.85rem; color:var(--text-secondary);">‚óè <span id="online-text">Online</span></div>
            <button class="btn btn-download" id="header-download-btn" style="font-size: 0.8rem; padding: 6px 12px; display: none;">üì≤ Download App</button>
        </div>
    </header>

    <main>
        <!-- Download App Section -->
        <section id="download-app-section" style="background: var(--card-background); border: 1px solid var(--border-color); border-radius: 12px; padding: 16px; box-shadow: 0 4px 12px var(--shadow); margin-bottom: 20px; display: none;">
            <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 200px;">
                    <div style="font-weight: 600; color: var(--primary-color); margin-bottom: 4px;">üì± Download as Web App</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary);">Install this podcast player on your device for offline access and a native app experience.</div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-download" id="download-app-btn" style="white-space: nowrap;">Download App</button>
                    <button class="btn btn-secondary" id="how-to-install-btn" style="white-space: nowrap;">How to Install</button>
                </div>
            </div>
            <div id="install-hint" style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px; display: none;"></div>
        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 8px; opacity: 0.7;">
            üí° Note: If your browser supports PWA installation, a "üì≤ Install Now" button will appear in the header after you interact with the page.
        </div>
        </section>

        <section id="player-section">
            <div id="now-playing">
                <h2 id="now-playing-title">Select an episode</h2>
                <div id="now-playing-description">Click 'Play' on any episode below to start listening.</div>
                <p class="now-playing-meta" id="now-playing-meta"></p>
            </div>
            <audio id="audio-player" controls preload="none">
                Your browser does not support the audio element.
            </audio>
        </section>

        <section class="filter-bar">
            <div class="filter-group">
                <label for="search-input">Search</label>
                <input type="search" id="search-input" placeholder="Filter by title or keyword...">
            </div>
            
            <div class="filter-group">
                <label for="sort-order">Sort Order</label>
                <select id="sort-order">
                    <option value="date-desc">Latest Episodes</option>
                    <option value="podcast-az">Podcast Name (A-Z)</option>
                    <option value="title-az">Episode Title (A-Z)</option>
                </select>
            </div>

            <div class="filter-group">
                <label for="podcast-filter">Filter by Podcast</label>
                <select id="podcast-filter">
                    <option value="all">All Podcasts</option>
                </select>
            </div>

            <div class="filter-group" style="flex: 0 0 auto;">
                <label>&nbsp;</label>
                <button id="manage-feeds-btn" class="btn btn-manage">Manage Feeds</button>
            </div>
        </section>

        <div class="results-meta" id="results-count"></div>

        <div id="episode-list">
            <div class="loading-message">Initializing...</div>
        </div>
    </main>
</div>

<div class="modal-overlay" id="manage-modal">
    <div class="modal-content">
        <div class="modal-header">
            <h2>Manage Subscriptions</h2>
            <button id="manage-close-btn" class="close-btn">√ó</button>
        </div>
        <div class="modal-body">
            
            <div>
                <div class="section-title">Search Directory (Apple Podcasts)</div>
                <div class="search-box">
                    <input type="text" id="directory-search-input" placeholder="Search for a podcast (e.g. 'History', 'Tech')...">
                    <button id="directory-search-btn" class="btn btn-play">Search</button>
                </div>
                <div id="directory-results" class="directory-results" style="display:none;"></div>
            </div>

            <div>
                <div class="section-title">Or Add Manual URL</div>
                <div class="search-box">
                    <input type="url" id="new-feed-input" placeholder="Paste RSS Feed URL here...">
                    <button id="add-feed-btn" class="btn btn-download">Add URL</button>
                </div>
            </div>

            <div>
                <div class="section-title">Import OPML from URL</div>
                <div class="search-box">
                    <input type="url" id="opml-url-input" placeholder="Paste OPML URL (https://...)">
                    <button id="import-opml-btn" class="btn btn-play">Import OPML</button>
                </div>
            </div>

            <div id="opml-import-status" style="display:none; border-top:1px solid var(--border-color); padding-top:10px;">
                <div class="section-title">OPML Import Status</div>
                <div id="opml-import-progress" style="color:var(--text-secondary);">
                    <span id="opml-spinner" class="spinner" style="display:none"></span>
                    <span id="opml-import-progress-text">Idle</span>
                </div>
                <div id="opml-import-summary" style="max-height:160px; overflow:auto; margin-top:8px; color:var(--text-color);"></div>
            </div>

            <div id="webapp-section" style="border-top:1px solid var(--border-color); padding-top:10px;">
                <div class="section-title">Web App</div>
                <div style="color:var(--text-secondary); margin-bottom:8px;">Installable PWA with offline caching and shortcuts. Use the button to install, or follow the iOS instructions.</div>
                <div style="display:flex; gap:8px; align-items:center;">
                    <button id="trigger-install-btn" class="btn btn-play">Install App</button>
                    <div id="webapp-info" style="color:var(--text-secondary); font-size:0.9rem;">Status: <span id="sw-status">Checking...</span></div>
                    <button id="clear-cache-btn" class="btn btn-download" title="Clear cached assets">Clear Cache</button>
                </div>
            </div>

            <div style="flex:1; overflow-y:auto; border-top:1px solid var(--border-color); padding-top:10px;">
                <div class="section-title">Your Subscriptions (<span id="sub-count">0</span>)</div>
                <div id="feed-manager-list"></div>
            </div>
        </div>
        <div class="modal-footer">
            <div style="display:flex; gap:8px; align-items:center;">
                <button id="export-opml-btn" class="btn btn-download">üì§ Export OPML</button>
                <button id="opml-upload-btn" class="btn btn-download">üì• Import OPML</button>
                <button id="install-footer-btn" class="btn btn-play">üì± Install App</button>
                <input type="file" id="opml-upload" accept=".opml,.xml" style="display:none" />
            </div>
            <div>
                <button id="reset-feeds-btn" class="btn btn-download" style="color: var(--error-color); border-color: var(--error-color);">Reset to Defaults</button>
                <button id="close-manager-btn" class="btn btn-download">Close</button>
            </div>
        </div>
    </div>
</div>

<div class="modal-overlay" id="install-instructions-modal" aria-hidden="true">
    <div class="modal-content" style="max-width:480px; max-height:420px;">
        <div class="modal-header">
            <h2>üì± Install as Web App</h2>
            <button id="close-install-instructions-btn" class="close-btn">√ó</button>
        </div>
        <div class="modal-body">
            <div style="font-size:0.95rem; color:var(--text-color); line-height: 1.6;">
                <div class="section-title">iOS (Safari)</div>
                <p>1. Tap the <strong>Share</strong> button (box with arrow ‚Üë)</p>
                <p>2. Scroll down and select <strong>"Add to Home Screen"</strong></p>
                <p>3. Tap "Add" in the top-right corner</p>
                
                <div class="section-title" style="margin-top:16px;">Android (Chrome)</div>
                <p>1. Tap the <strong>menu</strong> (3 dots in corner)</p>
                <p>2. Select <strong>"Install app"</strong> or <strong>"Add to Home screen"</strong></p>
                
                <div class="section-title" style="margin-top:16px;">Desktop (Chrome/Edge)</div>
                <p>1. Look for the <strong>install icon</strong> in the address bar (‚¨áÔ∏è or +)</p>
                <p>2. Or use <strong>menu</strong> ‚Üí <strong>"Install app"</strong></p>
                
                <div style="margin-top:16px; padding:12px; background: var(--hover-color); border-radius: 8px; font-size: 0.85rem;">
                    <strong>Benefits:</strong> Works offline, faster access, native app feel, no browser chrome.
                </div>
            </div>
            <div style="margin-top:16px; text-align:right;">
                <button id="close-install-instructions-close-btn" class="btn btn-download">Close</button>
            </div>
        </div>
    </div>
</div>

<script>
    /**
     * DEFAULT FEEDS
     */
    const defaultFeeds = [
        "https://allinchamathjason.libsyn.com/rss",
        "https://www.spreaker.com/show/5725007/episodes/feed",
        "https://atanyrate.podbean.com/feed.xml",
        "https://www.omnycontent.com/d/playlist/e73c998e-6e60-432f-8610-ae210140c5b1/825d4e29-b616-46f4-afd7-ae2b0013005c/8b1dd624-a026-43e9-8b57-ae2b00130066/podcast.rss",
        "https://feeds.simplecast.com/Nh1wIaXT",
        "https://feeds.megaphone.fm/CWT9205947236",
        "https://feeds.simplecast.com/szW8tJ16",
        "https://feeds.simplecast.com/CqxTohm7",
        "https://anchor.fm/s/e200a2d4/podcast/rss",
        "https://commoditiesfocus.libsyn.com/rss",
        "https://feed.podbean.com/mecardo/feed.xml",
        "https://feed.pod.space/enmorkhistoria",
        "https://etfspotlight.libsyn.com/rss",
        "https://feeds.megaphone.fm/ASD6061651607",
        "https://anchor.fm/s/9a1dfac/podcast/rss",
        "https://api.substack.com/feed/podcast/1161254.rss",
        "https://feeds.megaphone.fm/GLD9218176758",
        "https://feeds.megaphone.fm/BLM4409767076",
        "https://feeds.megaphone.fm/forwardguidance",
        "https://fridayfinishline.libsyn.com/rss",
        "https://feeds.libsyn.com/102774/rss",
        "https://feeds.captivate.fm/tbtahqp6sp3tresiqm4bzf/",
        "https://feeds.simplecast.com/qltQrd_8",
        "https://feeds.captivate.fm/insightful-investor/",
        "https://feeds.acast.com/public/shows/61e618c9d9ce8600126e77fa",
        "https://feeds.simplecast.com/Cyw1tJ_z",
        "https://api.substack.com/feed/podcast/656073.rss",
        "https://rss.buzzsprout.com/2034153.rss",
        "https://feeds.acast.com/public/shows/399a0c03-e9d0-4f9b-b8f1-64383023cb5c",
        "https://feeds.acast.com/public/shows/65fc2de9cce203001600e0a4",
        "https://macrohive.libsyn.com/rss",
        "https://feeds.megaphone.fm/macrohorizons",
        "https://rss.buzzsprout.com/2206288.rss",
        "https://feed.podbean.com/macrovoices/feed.xml",
        "https://feed.podbean.com/mckeanyflavell/feed.xml",
        "https://feeds.megaphone.fm/EWWMN1909747317",
        "https://rss.art19.com/money-for-the-rest-of-us",
        "https://feeds.megaphone.fm/ARML8165884693",
        "https://feeds.megaphone.fm/RRM3971763968",
        "https://api.sr.se/api/rss/program/4428",
        "https://feeds.acast.com/public/shows/65cf38bfd3bb5400161e754f",
        "https://feed.podbean.com/notesontheweekahead/feed.xml",
        "https://api.sr.se/api/rss/program/2523",
        "https://rss.art19.com/now-whats-next",
        "https://feeds.oggn.com/category/ogtw/feed/",
        "https://globaloil.libsyn.com/rss",
        "https://feeds.acast.com/public/shows/68dbe57346a2532cdd5600b8",
        "https://feeds.megaphone.fm/NSR7393370733",
        "https://api.sr.se/api/rss/pod/itunes/23791",
        "https://anchor.fm/s/10928cc60/podcast/rss",
        "https://feeds.megaphone.fm/RRM5151570998",
        "https://feedcdn.podbean.com/saxostrats/feed.xml",
        "https://feeds.megaphone.fm/NSR8236478683",
        "https://feed.podbean.com/spectrumcommodities/feed.xml",
        "https://feeds.megaphone.fm/onthemargin",
        "https://feeds.acast.com/public/shows/62d1f29df280fb0013f8a8a5",
        "https://feeds.soundcloud.com/users/soundcloud:users:233459956/sounds.rss",
        "https://feeds.megaphone.fm/THRH1653885106",
        "https://feed.pippa.io/public/shows/5c1d3a90e6bc692c38b2221f",
        "https://feed.podbean.com/foreignaffairsmagazine/feed.xml",
        "https://feeds.simplecast.com/QXaWSc4o",
        "https://feed.podbean.com/timizi/feed.xml",
        "https://rss.art19.com/the-insight",
        "https://feeds.captivate.fm/jacob-shapiro/",
        "https://feeds.libsyn.com/556816/rss",
        "https://feeds.megaphone.fm/ALFINVESTMENTSTRATEGYBV2974145286",
        "https://markethuddle.com/feed/podcast/",
        "https://feeds.megaphone.fm/TIFM6133783130",
        "https://anchor.fm/s/104219ecc/podcast/rss",
        "https://feeds.libsyn.com/218297/rss",
        "https://anchor.fm/s/eb1a1710/podcast/rss",
        "https://optionblock.libsyn.com/rss",
        "https://lancerobertsshow.libsyn.com/rss",
        "https://feeds.megaphone.fm/ARML4010200722",
        "https://feed.podbean.com/doubleline-the-sherman-show/feed.xml",
        "https://feeds.megaphone.fm/CSIS2753183348",
        "https://anchor.fm/s/eca7b164/podcast/rss",
        "https://rss.art19.com/thoughts-on-the-market",
        "https://feeds.megaphone.fm/GLD4256304026",
        "https://feeds.captivate.fm/top-traders-unplugged/",
        "https://anchor.fm/s/d9f6e850/podcast/rss",
        "https://anchor.fm/s/e9684be4/podcast/rss",
        "https://media.rss.com/unusualwhales/feed.xml",
        "https://feeds.libsyn.com/100426/rss",
        "https://www.spreaker.com/show/5725002/episodes/feed",
        "https://feeds.megaphone.fm/GEMINIMEDIA5571845247",
        "https://rss.buzzsprout.com/2437968.rss",
        "https://feeds.soundcloud.com/users/soundcloud:users:180427518/sounds.rss"
    ];

    // -- State --
    const STORAGE_KEY = 'podcasts_v1_feeds';
    let activeFeeds = [];
    let allEpisodes = [];
    let urlToTitle = {}; 
    
    // -- Elements --
    const audioPlayer = document.getElementById('audio-player');
    const episodeListEl = document.getElementById('episode-list');
    const statusBanner = document.getElementById('status-banner');
    const statusText = document.getElementById('status-text');
    
    // Ensure elements exist before using them
    if (!statusBanner || !statusText) {
        console.warn('Status banner elements not found, creating them dynamically');
        const banner = document.createElement('div');
        banner.id = 'status-banner';
        banner.className = 'status-banner--hidden';
        banner.style.cssText = 'margin: 10px 0; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; text-align: center;';
        const text = document.createElement('span');
        text.id = 'status-text';
        banner.appendChild(text);
        document.querySelector('header').insertBefore(banner, document.querySelector('header').children[2]);
    }

    // -- Initialization --
    function initializeApp() {
        initTheme();
        initFeeds();
        loadLibrary(activeFeeds);
        
        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/service-worker.js')
                .then((reg) => {
                    console.log('Service Worker Registered', reg);
                    updateSwStatus('Registered');
                    listenForSwUpdates(reg);
                })
                .catch(err => { console.log('SW Registration Failed', err); updateSwStatus('Registration Failed'); });
        }
    }

    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
        initializeApp();
    }

    function updateSwStatus(msg) {
            const el = document.getElementById('sw-status'); if (el) el.textContent = msg;
        }

        async function clearAppCache() {
            try {
                const cacheNames = await caches.keys();
                await Promise.all(cacheNames.map(name => caches.delete(name)));
                setStatus('Cache cleared', 'success', 3000);
                updateSwStatus('Cache cleared');
            } catch (e) { console.error(e); setStatus('Failed to clear cache', 'error', 4000); }
        }

        function listenForSwUpdates(reg) {
            if (!reg) return;
            if (reg.waiting) updateSwStatus('Update ready');
            reg.addEventListener('updatefound', () => updateSwStatus('Update found'));
            navigator.serviceWorker.addEventListener('controllerchange', () => updateSwStatus('Activated'));
        }

        document.getElementById('last-updated').textContent = `Last updated: ${new Date().toLocaleDateString()}`;

    // --- Theme Logic ---
    function initTheme() {
        const toggleBtn = document.getElementById('theme-toggle');
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
            document.documentElement.setAttribute('data-theme', 'dark');
            toggleBtn.textContent = '‚òÄÔ∏è';
        }

        toggleBtn.addEventListener('click', () => {
            const current = document.documentElement.getAttribute('data-theme');
            if (current === 'dark') {
                document.documentElement.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
                toggleBtn.textContent = 'üåô';
            } else {
                document.documentElement.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                toggleBtn.textContent = '‚òÄÔ∏è';
            }
        });
    }

    function initFeeds() {
        const stored = localStorage.getItem(STORAGE_KEY);
        if (stored) {
            try {
                activeFeeds = JSON.parse(stored);
            } catch(e) { activeFeeds = defaultFeeds; }
        } else {
            activeFeeds = [...defaultFeeds];
            saveFeeds();
        }
    }

    function saveFeeds() {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(activeFeeds));
    }

    // --- Feed Manager Logic ---
    function openManager() {
        document.getElementById('manage-modal').classList.add('active');
        renderManagerList();
    }
    
    function closeManager() {
        document.getElementById('manage-modal').classList.remove('active');
        // Clear search
        document.getElementById('directory-results').innerHTML = '';
        document.getElementById('directory-results').style.display = 'none';
        document.getElementById('directory-search-input').value = '';
        const oldScript = document.getElementById('itunes-script');
        if (oldScript) oldScript.remove();
    }

    function renderManagerList() {
        const container = document.getElementById('feed-manager-list');
        container.innerHTML = '';
        document.getElementById('sub-count').textContent = activeFeeds.length;
        
        activeFeeds.forEach(url => {
            const title = urlToTitle[url] || "Loading title...";
            const div = document.createElement('div');
            div.className = 'feed-list-item';

            const info = document.createElement('div');
            info.className = 'feed-info';

            const titleEl = document.createElement('div');
            titleEl.className = 'feed-title';
            titleEl.textContent = title;

            const urlEl = document.createElement('div');
            urlEl.className = 'feed-url';
            urlEl.textContent = url;

            info.appendChild(titleEl);
            info.appendChild(urlEl);
            div.appendChild(info);

            const btn = document.createElement('button');
            btn.className = 'btn-delete';
            btn.type = 'button';
            btn.textContent = 'Remove';
            btn.addEventListener('click', () => removeFeed(url));

            div.appendChild(btn);
            container.appendChild(div);
        });
    }

    function removeFeed(url) {
        if (!confirm("Remove this podcast?")) return;
        activeFeeds = activeFeeds.filter(f => f !== url);
        saveFeeds();
        renderManagerList();
        
        allEpisodes = allEpisodes.filter(ep => ep.originalFeed !== url);
        applyFilters();
        populateFilter(allEpisodes);
    }

    // --- FIXED Directory Search (JSONP) ---
    function searchDirectory() {
        const term = document.getElementById('directory-search-input').value.trim();
        if (!term) return;

        const resultsDiv = document.getElementById('directory-results');
        resultsDiv.style.display = 'block';
        resultsDiv.innerHTML = '<div style="padding:10px; color:var(--text-secondary);">Searching Apple Podcasts...</div>';

        // Clean up old script
        const oldScript = document.getElementById('itunes-script');
        if (oldScript) oldScript.remove();

        // JSONP script injection
        const script = document.createElement('script');
        script.id = 'itunes-script';
        const safeTerm = encodeURIComponent(term);
        script.src = `https://itunes.apple.com/search?media=podcast&entity=podcast&term=${safeTerm}&limit=15&callback=processItunesResults`;
        
        script.onerror = () => {
             resultsDiv.innerHTML = '<div style="padding:10px; color:var(--error-color);">Network error connecting to Apple.</div>';
        };

        document.body.appendChild(script);
    }

    // Global callback for JSONP
    window.processItunesResults = function(data) {
        const resultsDiv = document.getElementById('directory-results');
        resultsDiv.innerHTML = '';

        if (!data || data.resultCount === 0) {
            resultsDiv.innerHTML = '<div style="padding:10px; color:var(--text-secondary);">No results found.</div>';
            return;
        }

        data.results.forEach(pod => {
            const el = document.createElement('div');
            el.className = 'directory-item';

            const img = document.createElement('img');
            img.src = pod.artworkUrl60 || '';
            img.alt = pod.collectionName || 'cover';
            el.appendChild(img);

            const info = document.createElement('div');
            info.className = 'directory-info';
            const title = document.createElement('div');
            title.className = 'directory-title';
            title.textContent = pod.collectionName || '';
            const author = document.createElement('div');
            author.className = 'directory-author';
            author.textContent = pod.artistName || '';
            info.appendChild(title);
            info.appendChild(author);
            el.appendChild(info);

            const btn = document.createElement('button');
            btn.className = 'btn-add-feed';
            btn.textContent = 'Add';
            btn.addEventListener('click', () => addFromSearch(pod.feedUrl));
            el.appendChild(btn);

            resultsDiv.appendChild(el);
        });
    };

    function addFromSearch(url) {
        if (!url) return alert("Error: This podcast has no valid RSS feed.");
        if (activeFeeds.includes(url)) {
            alert("You are already subscribed to this feed.");
            return;
        }
        document.getElementById('new-feed-input').value = url;
        addNewFeed();
    }

    async function addNewFeed() {
        const input = document.getElementById('new-feed-input');
        if (!input) {
            console.error('new-feed-input element not found');
            setStatus('Input element not found', 'error', 3000);
            return;
        }
        
        const url = input.value.trim();
        if (!url) {
            setStatus('Please enter a valid URL', 'warning', 3000);
            return;
        }
        
        if (activeFeeds.includes(url)) {
            alert("This feed is already in your list.");
            return;
        }

        // Find the button that triggered this (prefer id, fallback to legacy attribute selectors)
        const oldButtons = document.querySelectorAll('button[onclick="addNewFeed()"]');
        const btn = document.getElementById('add-feed-btn') || (oldButtons.length > 0 ? oldButtons[oldButtons.length - 1] : null);
        const originalBtnText = btn ? btn.textContent : "Add";
        if (btn) btn.textContent = "Loading...";
        input.disabled = true;
        setStatus('Adding feed...', 'info');

        const result = await fetchRSS(url);
        if (result) {
            activeFeeds.push(url);
            saveFeeds();
            
            let newEps = [];
            if (result.type === 'xml_string') newEps = parseXML(result.content, url);
            else newEps = parseJSON(result.content, url);
            
            if (newEps.length > 0) {
                urlToTitle[url] = newEps[0].podcastTitle;
                allEpisodes = allEpisodes.concat(newEps);
                sortEpisodes(allEpisodes, document.getElementById('sort-order').value);
                
                populateFilter(allEpisodes);
                applyFilters();
                renderManagerList();
                
                input.value = "";
                alert(`Subscribed to "${newEps[0].podcastTitle}"`);
            } else {
                alert("Feed found, but contained no episodes.");
            }
        } else {
            alert("Could not load feed. Check URL or CORS.");
        }
        input.disabled = false;
        if(event.target) event.target.textContent = originalBtnText;
    }

    function resetFeeds() {
        if(confirm("This will delete all custom feeds and restore the default list. Are you sure?")) {
            activeFeeds = [...defaultFeeds];
            saveFeeds();
            location.reload(); 
        }
    }

    // --- Fetch & Core Logic ---
    async function fetchRSS(url) {
        console.log(`Fetching RSS: ${url}`);
        
        if (!url || !url.startsWith('http')) {
            console.log(`‚úó Invalid URL: ${url}`);
            return null;
        }
        
        // Try corsproxy.io first
        try {
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;
            console.log(`Trying corsproxy.io: ${proxyUrl}`);
            const res = await fetchWithTimeout(proxyUrl, 8000);
            if (res.ok) {
                const text = await res.text();
                console.log(`‚úì Success with corsproxy.io for ${url}`);
                return { content: text, type: 'xml_string' };
            } else {
                console.log(`‚úó corsproxy.io returned status ${res.status}`);
            }
        } catch (e) {
            console.log(`‚úó corsproxy.io failed for ${url}:`, e.message);
        }

        // Try allorigins.win second
        try {
            const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
            console.log(`Trying allorigins.win: ${proxyUrl}`);
            const res = await fetchWithTimeout(proxyUrl, 8000);
            const data = await res.json();
            if (data.contents) {
                console.log(`‚úì Success with allorigins.win for ${url}`);
                return { content: data.contents, type: 'xml_string' };
            } else {
                console.log(`‚úó allorigins.win returned no contents`);
            }
        } catch (e) {
            console.log(`‚úó allorigins.win failed for ${url}:`, e.message);
        }
        
        // Try rss2json.com third
        try {
            const proxyUrl = `https://api.rss2json.com/v1/api.json?rss_url=${encodeURIComponent(url)}`;
            console.log(`Trying rss2json.com: ${proxyUrl}`);
            const res = await fetchWithTimeout(proxyUrl, 5000);
            const data = await res.json();
            if (data.status === 'ok') {
                console.log(`‚úì Success with rss2json.com for ${url}`);
                return { content: data, type: 'json_obj' };
            } else {
                console.log(`‚úó rss2json.com returned status: ${data.status}`);
            }
        } catch (e) {
            console.log(`‚úó rss2json.com failed for ${url}:`, e.message);
        }

        console.log(`‚úó All proxies failed for ${url}`);
        return null; 
    }

    async function fetchWithTimeout(resource, timeout = 8000) {
        const controller = new AbortController();
        const id = setTimeout(() => controller.abort(), timeout);
        const response = await fetch(resource, { signal: controller.signal });
        clearTimeout(id);
        return response;
    }

    // --- Player Logic ---
    function playEpisode(url, title, podcastTitle) {
        if (!url) return;
        let secureUrl = url.replace(/^http:\/\//, 'https://');
        document.getElementById('now-playing-title').textContent = title;
        document.getElementById('now-playing-description').textContent = `Playing: ${podcastTitle}`;
        document.getElementById('now-playing-meta').textContent = "Buffering...";
        audioPlayer.src = secureUrl;
        audioPlayer.play()
            .then(() => {
                document.getElementById('now-playing-meta').textContent = "Now Playing";
                setStatus(`Playing: ${title}`, 'success', 3000);
            })
            .catch(e => {
                if (secureUrl !== url) { audioPlayer.src = url; audioPlayer.play(); } 
                else { setStatus("Playback failed.", 'error'); }
            });
    }

    async function downloadEpisode(url, filename, btn) {
        const originalText = btn.textContent;
        btn.textContent = "Downloading...";
        btn.disabled = true;
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error("Blocked");
            const blob = await response.blob();
            const blobUrl = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = blobUrl;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(blobUrl);
            btn.textContent = "Saved!";
        } catch (error) {
            window.open(url, '_blank');
            btn.textContent = "Opened Tab";
            setStatus("Direct download blocked. Opened in new tab.", "warning", 4000);
        }
        setTimeout(() => { btn.textContent = originalText; btn.disabled = false; }, 2000);
    }

    // --- Data Loading ---
    async function loadLibrary(feeds) {
        if (!feeds || feeds.length === 0) {
            episodeListEl.innerHTML = '<div class="error-message">No feeds configured. Please add some podcasts.</div>';
            setStatus("No feeds configured.", 'info');
            return;
        }

        setStatus(`Fetching ${feeds.length} podcasts...`, 'info');
        episodeListEl.innerHTML = '<div class="loading-message">Loading feeds...</div>';
        
        allEpisodes = [];
        let successCount = 0;
        let failCount = 0;
        let isFirstLoad = true;

        const promises = feeds.map(async (url) => {
            try {
                const result = await fetchRSS(url);
                if (result) {
                    let newEpisodes = [];
                    if (result.type === 'xml_string') newEpisodes = parseXML(result.content, url);
                    else if (result.type === 'json_obj') newEpisodes = parseJSON(result.content, url);

                    if (newEpisodes.length > 0) {
                        successCount++;
                        urlToTitle[url] = newEpisodes[0].podcastTitle;
                        allEpisodes = allEpisodes.concat(newEpisodes);
                        sortEpisodes(allEpisodes, document.getElementById('sort-order').value);
                        
                        if (isFirstLoad) {
                            episodeListEl.innerHTML = '';
                            isFirstLoad = false;
                        }
                        populateFilter(allEpisodes);
                        applyFilters();
                        setStatus(`Loaded ${successCount} feeds...`, 'info');
                    } else {
                        urlToTitle[url] = "Empty Feed";
                        failCount++;
                    }
                } else {
                    urlToTitle[url] = "Failed to Load";
                    failCount++;
                }
            } catch (e) {
                console.error(`Error loading feed ${url}:`, e);
                urlToTitle[url] = "Error";
                failCount++;
            }
        });

        await Promise.allSettled(promises);
        
        if (allEpisodes.length === 0) {
            episodeListEl.innerHTML = `<div class="error-message">
                <p>Failed to load podcasts.</p>
                <p style="font-size: 0.85rem; margin-top: 8px;">${failCount} feeds failed. Check console for details.</p>
            </div>`;
            setStatus(`Failed to load any podcasts (${failCount} errors).`, 'error');
        } else {
            setStatus(`Done! Loaded ${allEpisodes.length} episodes from ${successCount} feeds.`, 'success', 5000);
        }
    }

    // --- Parsers ---
    function parseXML(xmlString, url) {
        const parser = new DOMParser();
        const xml = parser.parseFromString(xmlString, "text/xml");
        let channel = xml.querySelector('channel') || xml.querySelector('feed');
        if (!channel) return [];

        let podcastTitle = channel.querySelector('title')?.textContent || "Unknown Podcast";
        let items = Array.from(channel.querySelectorAll('item'));
        if (items.length === 0) items = Array.from(channel.querySelectorAll('entry'));

        return items.map(item => {
            const title = item.querySelector('title')?.textContent || 'Untitled';
            const pubDateStr = item.querySelector('pubDate')?.textContent || item.querySelector('published')?.textContent;
            const pubDate = pubDateStr ? new Date(pubDateStr) : new Date();
            let description = item.querySelector('description')?.textContent || item.querySelector('summary')?.textContent || '';
            const contentEncoded = item.getElementsByTagName('content:encoded')[0]?.textContent || description;
            const cleanDesc = description.replace(/<[^>]*>/g, '').substring(0, 180) + '...';

            let audioUrl = null; let fileSize = null;
            const enclosure = item.querySelector('enclosure');
            if (enclosure) { audioUrl = enclosure.getAttribute('url'); fileSize = enclosure.getAttribute('length'); }
            else { const link = item.querySelector('link[rel="enclosure"]'); if (link) audioUrl = link.getAttribute('href'); }
            let duration = item.getElementsByTagName('itunes:duration')[0]?.textContent;

            if (!audioUrl) return null;
            return { title, podcastTitle, pubDate, description: cleanDesc, fullContent: contentEncoded, audioUrl, duration, fileSize, originalFeed: url };
        }).filter(Boolean);
    }

    function parseJSON(data, url) {
        const podcastTitle = data.feed.title || "Unknown Podcast";
        return data.items.map(item => ({
            title: item.title, podcastTitle, pubDate: new Date(item.pubDate),
            description: (item.description || '').replace(/<[^>]*>/g, '').substring(0, 180) + '...',
            fullContent: item.content || item.description, audioUrl: item.enclosure.link,
            duration: null, fileSize: item.enclosure.length, originalFeed: url
        }));
    }

    function sortEpisodes(episodes, sortType) {
        if (sortType === 'date-desc') episodes.sort((a, b) => b.pubDate - a.pubDate);
        else if (sortType === 'podcast-az') episodes.sort((a, b) => a.podcastTitle.localeCompare(b.podcastTitle));
        else if (sortType === 'title-az') episodes.sort((a, b) => a.title.localeCompare(b.title));
    }

    function renderEpisodes(episodes) {
        const displayList = episodes.slice(0, 50);
        episodeListEl.innerHTML = '';
        if (displayList.length === 0) { episodeListEl.innerHTML = '<div class="loading-message">No episodes match.</div>'; return; }

        const fragment = document.createDocumentFragment();
        displayList.forEach(ep => {
            const el = document.createElement('div');
            el.className = 'episode-item';
            let badgesHtml = `<span class="badge">${ep.pubDate.toLocaleDateString()}</span>`;
            if (ep.duration) badgesHtml += `<span class="badge">‚è± ${formatDuration(ep.duration)}</span>`;
            if (ep.fileSize) badgesHtml += `<span class="badge">üíæ ${formatSize(ep.fileSize)}</span>`;
            const safeFilename = `${ep.podcastTitle} - ${ep.title}.mp3`.replace(/[^a-z0-9 \.\-_]/gi, '_');

            // Build episode DOM safely without injecting untrusted HTML
            const info = document.createElement('div');
            info.className = 'episode-info';

            const podName = document.createElement('div');
            podName.className = 'podcast-name';
            podName.textContent = ep.podcastTitle;

            const epTitle = document.createElement('h3');
            epTitle.className = 'episode-title';
            epTitle.textContent = ep.title;

            const meta = document.createElement('div');
            meta.className = 'episode-meta-badges';
            // badgesHtml contains only safe, generated text; add spans instead of innerHTML
            const dateSpan = document.createElement('span'); dateSpan.className = 'badge'; dateSpan.textContent = ep.pubDate.toLocaleDateString(); meta.appendChild(dateSpan);
            if (ep.duration) { const dspan = document.createElement('span'); dspan.className = 'badge'; dspan.textContent = `‚è± ${formatDuration(ep.duration)}`; meta.appendChild(dspan); }
            if (ep.fileSize) { const fspan = document.createElement('span'); fspan.className = 'badge'; fspan.textContent = `üíæ ${formatSize(ep.fileSize)}`; meta.appendChild(fspan); }

            const desc = document.createElement('div'); desc.className = 'episode-description'; desc.textContent = ep.description || '';

            info.appendChild(podName);
            info.appendChild(epTitle);
            info.appendChild(meta);
            info.appendChild(desc);

            if (ep.fullContent) {
                const toggleBtn = document.createElement('button');
                toggleBtn.className = 'toggle-notes';
                toggleBtn.type = 'button';
                toggleBtn.textContent = 'Show Notes';
                const fullNotes = document.createElement('div');
                fullNotes.className = 'full-notes';
                fullNotes.textContent = ep.fullContent;
                toggleBtn.addEventListener('click', () => fullNotes.classList.toggle('active'));
                info.appendChild(toggleBtn);
                info.appendChild(fullNotes);
            }

            const action = document.createElement('div'); action.className = 'action-row';
            const playBtn = document.createElement('button'); playBtn.className = 'btn btn-play'; playBtn.textContent = '‚ñ∂ Play Episode';
            const downBtn = document.createElement('button'); downBtn.className = 'btn btn-download'; downBtn.textContent = 'Download';
            playBtn.addEventListener('click', () => playEpisode(ep.audioUrl, ep.title, ep.podcastTitle));
            downBtn.addEventListener('click', () => downloadEpisode(ep.audioUrl, safeFilename, downBtn));
            action.appendChild(playBtn); action.appendChild(downBtn);

            el.appendChild(info);
            el.appendChild(action);
            fragment.appendChild(el);
        });
        episodeListEl.appendChild(fragment);
        document.getElementById('results-count').textContent = `Showing ${displayList.length} episodes`;
    }

    function formatDuration(secStr) {
        if (!secStr) return ''; if (secStr.includes(':')) return secStr;
        const sec = parseInt(secStr, 10); if (isNaN(sec)) return '';
        const h = Math.floor(sec / 3600); const m = Math.floor((sec % 3600) / 60);
        return h > 0 ? `${h}h ${m}m` : `${m}m`;
    }
    function formatSize(bytes) {
        if (!bytes) return ''; const mb = parseInt(bytes) / (1024 * 1024);
        return isNaN(mb) ? '' : `${mb.toFixed(1)} MB`;
    }
    function escapeHtml(text) {
        if (!text) return '';
        return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }

    function populateFilter(episodes) {
        const select = document.getElementById('podcast-filter');
        const currentVal = select.value;
        const uniquePods = [...new Set(episodes.map(e => e.podcastTitle))].sort();
        select.innerHTML = '<option value="all">All Podcasts</option>';
        uniquePods.forEach(title => {
            const opt = document.createElement('option'); opt.value = title; opt.textContent = title;
            if (title === currentVal) opt.selected = true; select.appendChild(opt);
        });
    }

    function applyFilters() {
        const term = document.getElementById('search-input').value.toLowerCase();
        const podFilter = document.getElementById('podcast-filter').value;
        const sortType = document.getElementById('sort-order').value;
        let filtered = allEpisodes.filter(ep => {
            return (ep.title.toLowerCase().includes(term) || ep.description.toLowerCase().includes(term)) &&
                   (podFilter === 'all' || ep.podcastTitle === podFilter);
        });
        sortEpisodes(filtered, sortType);
        renderEpisodes(filtered);
    }

    function setStatus(msg, type = 'info', duration = 0) {
        statusText.textContent = msg; statusBanner.className = `status-banner--${type}`;
        if (duration > 0) setTimeout(() => statusBanner.className = 'status-banner--hidden', duration);
    }

    document.getElementById('directory-search-input').addEventListener('keypress', function (e) {
        if (e.key === 'Enter') searchDirectory();
    });

    document.getElementById('search-input').addEventListener('input', applyFilters);
    document.getElementById('podcast-filter').addEventListener('change', applyFilters);
    document.getElementById('sort-order').addEventListener('change', applyFilters);

    // OPML Import/Export handlers
    document.getElementById('opml-upload').addEventListener('change', function (e) { importOPMLFromInput(e); });

    function exportOPML() {
        const now = new Date().toISOString().slice(0,10);
        const headTitle = 'Podcasts Subscriptions';
        const items = activeFeeds.map(url => {
            const title = escapeXml(urlToTitle[url] || url);
            return `<outline type="rss" text="${title}" title="${title}" xmlUrl="${escapeXml(url)}"/>`;
        }).join('\n        ');
        const opml = `<?xml version="1.0" encoding="UTF-8"?>\n<opml version="1.0">\n  <head>\n    <title>${headTitle}</title>\n    <dateCreated>${new Date().toUTCString()}</dateCreated>\n  </head>\n  <body>\n        ${items}\n  </body>\n</opml>`;
        const blob = new Blob([opml], { type: 'text/xml' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `podcasts-${now}.opml`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);
        setStatus('OPML exported', 'success', 3000);
    }

    async function importOPMLFromUrl() {
        const input = document.getElementById('opml-url-input');
        const url = input.value.trim();
        if (!url) return alert('Please paste an OPML URL first.');
        input.disabled = true;
        showOpmlImportPanel();
        setOpmlProgress('Fetching OPML...');
        try {
            const text = await fetchOPMLWithProxies(url);
            if (!text) throw new Error('Unable to fetch OPML');
            const report = await importOPMLWithReport(text, (msg) => setOpmlProgress(msg));
            finalizeImportReport(report);
            input.value = '';
        } catch (e) {
            const msg = e && e.message ? e.message : 'Failed to fetch/parse OPML';
            setStatus('OPML import error', 'error', 6000);
            setOpmlProgress(msg);
            console.error('OPML import error:', e);
            alert('OPML import error: ' + msg);
        }
        input.disabled = false;
    }

    function importOPMLFromInput(evt) {
        const file = evt.target && evt.target.files && evt.target.files[0];
        if (!file) return;
        showOpmlImportPanel();
        setOpmlProgress('Reading file...');
        const reader = new FileReader();
        reader.onload = async () => {
            const text = reader.result;
            try {
                const report = await importOPMLWithReport(text, (msg) => setOpmlProgress(msg));
                finalizeImportReport(report);
            } catch (e) {
                const msg = e && e.message ? e.message : 'Failed to parse OPML';
                setStatus('OPML parse error', 'error', 6000);
                setOpmlProgress(msg);
                console.error('OPML parse error:', e);
                alert('OPML parse error: ' + msg);
            }
            evt.target.value = '';
        };
        reader.readAsText(file);
    }

    async function fetchOPMLWithProxies(url) {
        // Try direct fetch first
        try {
            const res = await fetchWithTimeout(url, 8000);
            if (res.ok) return await res.text();
        } catch (e) {}

        // Try corsproxy.io
        try {
            const proxy = `https://corsproxy.io/?${encodeURIComponent(url)}`;
            const res = await fetchWithTimeout(proxy, 8000);
            if (res.ok) return await res.text();
        } catch (e) {}

        // Try allorigins
        try {
            const proxy = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
            const res = await fetchWithTimeout(proxy, 8000);
            const data = await res.json();
            if (data && data.contents) return data.contents;
        } catch (e) {}

        // Give up
        return null;
    }

    function extractOpmlUrlsFromText(text) {
        const urls = new Set();
        let m;
        const dbl = /xmlUrl\s*=\s*"([^"]+)"/ig;
        while ((m = dbl.exec(text))) urls.add(m[1].trim());
        const sgl = /xmlUrl\s*=\s*'([^']+)'/ig;
        while ((m = sgl.exec(text))) urls.add(m[1].trim());
        const urlDbl = /url\s*=\s*"([^"]+)"/ig;
        while ((m = urlDbl.exec(text))) {
            const u = m[1].trim(); if (/^https?:\/\//i.test(u)) urls.add(u);
        }
        const urlSgl = /url\s*=\s*'([^']+)'/ig;
        while ((m = urlSgl.exec(text))) {
            const u = m[1].trim(); if (/^https?:\/\//i.test(u)) urls.add(u);
        }
        return Array.from(urls);
    }

    async function importOPMLWithReport(text, progressCb) {
        progressCb = progressCb || (() => {});
        const parser = new DOMParser();

        // Try parsing as XML and detect parser errors
        let xml = parser.parseFromString(text, 'application/xml');
        const hasParserError = !!(xml.querySelector && (xml.querySelector('parsererror') || xml.getElementsByTagName('parsererror').length));

        if (hasParserError) {
            console.warn('OPML parse error detected, attempting cleanup and re-parse.');
            // Strip BOM and problematic control characters then retry
            const cleaned = String(text).replace(/^\uFEFF/, '').replace(/[\x00-\x08\x0B\x0C\x0E-\x1F]/g, '');
            xml = parser.parseFromString(cleaned, 'application/xml');
            if (xml.querySelector && (xml.querySelector('parsererror') || xml.getElementsByTagName('parsererror').length)) {
                console.warn('Cleanup did not fix parse error. Falling back to regex extraction.');
                const urls = extractOpmlUrlsFromText(cleaned);
                if (urls.length === 0) throw new Error('No feeds found (parsing failed, and fallback found none).');

                // Build outlines from urls for downstream processing
                const outlines = urls.map(u => ({ url: u, title: '' }));
                return await processOutlinesWithReport(outlines, progressCb);
            }
        }

        // If parsing succeeded, traverse DOM to collect outlines
        const outlines = [];
        function traverse(node) {
            const children = Array.from(node.children || []);
            children.forEach(child => {
                if (child.tagName && child.tagName.toLowerCase() === 'outline') {
                    const url = child.getAttribute('xmlUrl') || child.getAttribute('url');
                    if (url) outlines.push({url, title: child.getAttribute('title') || child.getAttribute('text') || ''});
                    // Recurse in case of grouped outlines
                    traverse(child);
                } else {
                    // Recurse regardless (some OPMLs use nested groups differently)
                    traverse(child);
                }
            });
        }
        traverse(xml);

        if (outlines.length === 0) {
            // As a last resort use regex extractor on text
            const fallback = extractOpmlUrlsFromText(text);
            if (fallback.length === 0) throw new Error('No feeds found');
            const outlinesFromFallback = fallback.map(u => ({ url: u, title: '' }));
            return await processOutlinesWithReport(outlinesFromFallback, progressCb);
        }

        return await processOutlinesWithReport(outlines, progressCb);
    }

    async function processOutlinesWithReport(outlines, progressCb) {
        const report = { total: outlines.length, added: [], skipped: [], malformed: [] };
        for (let i = 0; i < outlines.length; i++) {
            const o = outlines[i];
            progressCb(`Processing ${i+1}/${outlines.length} ‚Äî added ${report.added.length}, skipped ${report.skipped.length}, malformed ${report.malformed.length}`);
            await new Promise(r => setTimeout(r, 50)); // small pause to allow UI updates
            let url = (o.url || o.url) ? (o.url || '').trim() : '';
            try {
                // Basic validation
                const parsed = new URL(url);
                url = parsed.href;
            } catch (e) {
                report.malformed.push(o);
                continue;
            }
            if (activeFeeds.includes(url)) {
                report.skipped.push(url);
            } else {
                activeFeeds.push(url);
                report.added.push(url);
            }
        }
        // Persist and reload
        if (report.added.length > 0) {
            saveFeeds();
            await loadLibrary(activeFeeds);
            renderManagerList();
        }
        return report;
    }

    function finalizeImportReport(report) {
        setOpmlProgress(`Done ‚Äî ${report.added.length} added, ${report.skipped.length} skipped, ${report.malformed.length} malformed.`);
        setStatus(`Imported ${report.added.length} feeds`, report.added.length > 0 ? 'success' : 'info', 4000);
        showImportSummary(report);
    }

    function showImportSummary(report) {
        const summaryEl = document.getElementById('opml-import-summary');
        summaryEl.innerHTML = '';

        const addedDiv = document.createElement('div');
        const addedStrong = document.createElement('strong'); addedStrong.textContent = 'Added:';
        addedDiv.appendChild(addedStrong);
        addedDiv.appendChild(document.createTextNode(` ${report.added.length}`));
        summaryEl.appendChild(addedDiv);

        if (report.added.length) {
            const ul = document.createElement('ul');
            report.added.forEach(u => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                try { a.href = u; } catch(e) { a.href = '#'; }
                a.target = '_blank';
                a.textContent = u;
                li.appendChild(a);
                ul.appendChild(li);
            });
            summaryEl.appendChild(ul);
        }

        const skippedDiv = document.createElement('div');
        const skippedStrong = document.createElement('strong'); skippedStrong.textContent = 'Skipped (already present):';
        skippedDiv.appendChild(skippedStrong);
        skippedDiv.appendChild(document.createTextNode(` ${report.skipped.length}`));
        summaryEl.appendChild(skippedDiv);
        if (report.skipped.length) {
            const ul = document.createElement('ul');
            report.skipped.forEach(u => {
                const li = document.createElement('li'); li.textContent = u; ul.appendChild(li);
            });
            summaryEl.appendChild(ul);
        }

        const malformedDiv = document.createElement('div');
        const malformedStrong = document.createElement('strong'); malformedStrong.textContent = 'Malformed:';
        malformedDiv.appendChild(malformedStrong);
        malformedDiv.appendChild(document.createTextNode(` ${report.malformed.length}`));
        summaryEl.appendChild(malformedDiv);
        if (report.malformed.length) {
            const ul = document.createElement('ul');
            report.malformed.forEach(o => {
                const li = document.createElement('li');
                li.textContent = `${o.title || ''}: ${o.url || ''}`;
                ul.appendChild(li);
            });
            summaryEl.appendChild(ul);
        }
    }

    function showOpmlImportPanel() {
        document.getElementById('opml-import-status').style.display = 'block';
        document.getElementById('opml-import-summary').innerHTML = '';
    }
    function setOpmlProgress(msg) {
        const spinner = document.getElementById('opml-spinner');
        const text = document.getElementById('opml-import-progress-text');
        if (text) text.textContent = msg;
        if (spinner) {
            if (/Processing|Fetching|Reading/i.test(msg)) spinner.style.display = 'inline-block';
            else spinner.style.display = 'none';
        }
    }

    function escapeXml(str) {
        if (!str) return '';
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
    }

    // --- PWA Install Helpers ---
    let deferredInstallPrompt = null;
    const downloadAppBtn = document.getElementById('download-app-btn');
    const headerDownloadBtn = document.getElementById('header-download-btn');
    const installHint = document.getElementById('install-hint');
    const downloadSection = document.getElementById('download-app-section');

    function isIos() { return /iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()); }
    function isAndroid() { return /android/.test(navigator.userAgent.toLowerCase()); }
    function isInStandaloneMode() { return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true; }

    // Show/hide download UI based on install availability
    function updateInstallUI() {
        if (isInStandaloneMode()) {
            // Already installed - hide everything
            if (downloadSection) downloadSection.style.display = 'none';
            if (headerDownloadBtn) headerDownloadBtn.style.display = 'none';
            return;
        }
        
        // Show download section by default
        if (downloadSection) downloadSection.style.display = 'block';
        
        // Update hint text
        if (installHint) {
            installHint.style.display = 'block';
            if (isIos()) {
                installHint.textContent = 'üí° On iOS: Tap the Share button (box with arrow ‚Üë) ‚Üí "Add to Home Screen"';
            } else if (isAndroid()) {
                installHint.textContent = 'üí° On Android: Tap menu (3 dots) ‚Üí "Install app" or "Add to Home screen"';
            } else {
                installHint.textContent = 'üí° Click "Download App" to install, or use your browser menu';
            }
        }
    }

    window.addEventListener('beforeinstallprompt', (e) => {
        console.log('beforeinstallprompt event fired - PWA install available');
        e.preventDefault();
        deferredInstallPrompt = e;
        if (!isInStandaloneMode()) {
            // Show header button and hide download section to avoid duplicates
            if (headerDownloadBtn) {
                headerDownloadBtn.style.display = 'inline-block';
                headerDownloadBtn.textContent = 'üì≤ Install Now';
            }
            if (downloadSection) downloadSection.style.display = 'none';
        }
    });

    // Debug: Log if beforeinstallprompt doesn't fire
    setTimeout(() => {
        if (!deferredInstallPrompt && !isInStandaloneMode()) {
            console.log('Note: beforeinstallprompt event did not fire. This is normal if:');
            console.log('1. Site is not served over HTTPS');
            console.log('2. App is already installed');
            console.log('3. Browser does not support PWA installation');
            console.log('4. User has not interacted with the page yet');
        }
    }, 3000);

    async function handleInstall() {
        if (isInStandaloneMode()) {
            setStatus('App already installed', 'success', 3000);
            return;
        }
        
        if (isIos()) {
            document.getElementById('install-instructions-modal').classList.add('active');
            return;
        }
        
        if (deferredInstallPrompt) {
            deferredInstallPrompt.prompt();
            const choice = await deferredInstallPrompt.userChoice;
            if (choice && choice.outcome === 'accepted') {
                setStatus('App installed successfully!', 'success', 4000);
            } else {
                setStatus('Install dismissed', 'info', 3000);
            }
            deferredInstallPrompt = null;
        } else {
            // Fallback: show instructions if prompt not available (e.g. desktop Chrome manual install)
            document.getElementById('install-instructions-modal').classList.add('active');
        }
    }

    // Header download button
    if (headerDownloadBtn) {
        headerDownloadBtn.addEventListener('click', handleInstall);
        console.log('Header download button listener attached');
    } else {
        console.warn('Header download button not found');
    }

    // Download section button
    if (downloadAppBtn) {
        downloadAppBtn.addEventListener('click', handleInstall);
        console.log('Download app button listener attached');
    } else {
        console.warn('Download app button not found');
    }

    // How to Install button - just shows instructions
    const howToInstallBtn = document.getElementById('how-to-install-btn');
    if (howToInstallBtn) {
        howToInstallBtn.addEventListener('click', () => {
            document.getElementById('install-instructions-modal').classList.add('active');
        });
        console.log('How to install button listener attached');
    } else {
        console.warn('How to install button not found');
    }

    window.addEventListener('appinstalled', () => {
        setStatus('App installed successfully!', 'success', 4000);
        if (headerDownloadBtn) headerDownloadBtn.style.display = 'none';
        if (downloadSection) downloadSection.style.display = 'none';
        document.getElementById('install-instructions-modal').classList.remove('active');
    });

    // Initialize UI on load
    updateInstallUI();

    // Helper used by Manage modal to trigger install flow
    function triggerInstall() {
        handleInstall();
    }

    // --- Network status indicator ---
    function updateOnlineStatus() {
        const el = document.getElementById('online-status');
        const txt = document.getElementById('online-text');
        if (!el || !txt) return;
        if (navigator.onLine) {
            el.style.color = 'var(--success-color)';
            txt.textContent = 'Online';
        } else {
            el.style.color = 'var(--error-color)';
            txt.textContent = 'Offline';
        }
    }

    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    // initialize
    updateOnlineStatus();

    // --- FIXES FOR BUTTONS AND PODCAST LOADING ---
    
    // Ensure all required DOM elements exist
    function ensureDomElements() {
        // Check for missing status elements
        if (!document.getElementById('status-banner')) {
            const banner = document.createElement('div');
            banner.id = 'status-banner';
            banner.className = 'status-banner--hidden';
            banner.style.cssText = 'margin: 10px 0; padding: 8px 12px; border-radius: 6px; font-size: 0.9rem; text-align: center;';
            const text = document.createElement('span');
            text.id = 'status-text';
            banner.appendChild(text);
            const header = document.querySelector('header');
            if (header) {
                header.insertBefore(banner, header.children[2]);
            }
        }
        
        // Check for missing itunes-script placeholder
        if (!document.getElementById('itunes-script')) {
            const placeholder = document.createElement('div');
            placeholder.id = 'itunes-script';
            placeholder.style.display = 'none';
            document.body.appendChild(placeholder);
        }
        
        // Re-attach button event listeners if they're missing
        setTimeout(() => {
            const headerBtn = document.getElementById('header-download-btn');
            const downloadBtn = document.getElementById('download-app-btn');
            const howToBtn = document.getElementById('how-to-install-btn');

            if (headerBtn && !headerBtn._listenerAttached) {
                headerBtn.addEventListener('click', handleInstall);
                headerBtn._listenerAttached = true;
                console.log('‚úì Header download button listener re-attached');
            }

            if (downloadBtn && !downloadBtn._listenerAttached) {
                downloadBtn.addEventListener('click', handleInstall);
                downloadBtn._listenerAttached = true;
                console.log('‚úì Download app button listener re-attached');
            }

            if (howToBtn && !howToBtn._listenerAttached) {
                howToBtn.addEventListener('click', () => {
                    const modal = document.getElementById('install-instructions-modal');
                    if (modal) modal.classList.add('active');
                });
                howToBtn._listenerAttached = true;
                console.log('‚úì How to install button listener re-attached');
            }

            // Attach Manage / Manager-related buttons
            const manageBtn = document.getElementById('manage-feeds-btn');
            if (manageBtn && !manageBtn._listenerAttached) {
                manageBtn.addEventListener('click', openManager);
                manageBtn._listenerAttached = true;
                console.log('‚úì Manage feeds button listener attached');
            }

            const manageCloseBtn = document.getElementById('manage-close-btn');
            if (manageCloseBtn && !manageCloseBtn._listenerAttached) {
                manageCloseBtn.addEventListener('click', closeManager);
                manageCloseBtn._listenerAttached = true;
                console.log('‚úì Manage close button listener attached');
            }

            const directorySearchBtn = document.getElementById('directory-search-btn');
            if (directorySearchBtn && !directorySearchBtn._listenerAttached) {
                directorySearchBtn.addEventListener('click', searchDirectory);
                directorySearchBtn._listenerAttached = true;
                console.log('‚úì Directory search button listener attached');
            }

            // Attach Add URL and Import OPML buttons
            const addFeedBtn = document.getElementById('add-feed-btn');
            if (addFeedBtn && !addFeedBtn._listenerAttached) {
                addFeedBtn.addEventListener('click', addNewFeed);
                addFeedBtn._listenerAttached = true;
                console.log('‚úì Add feed button listener attached');
            }
            const importOpmlBtn = document.getElementById('import-opml-btn');
            if (importOpmlBtn && !importOpmlBtn._listenerAttached) {
                importOpmlBtn.addEventListener('click', importOPMLFromUrl);
                importOpmlBtn._listenerAttached = true;
                console.log('‚úì Import OPML button listener attached');
            }

            // Web app / cache / export / import / reset
            const triggerInstallBtn = document.getElementById('trigger-install-btn');
            if (triggerInstallBtn && !triggerInstallBtn._listenerAttached) {
                triggerInstallBtn.addEventListener('click', triggerInstall);
                triggerInstallBtn._listenerAttached = true;
                console.log('‚úì Trigger install button attached');
            }

            const clearCacheBtn = document.getElementById('clear-cache-btn');
            if (clearCacheBtn && !clearCacheBtn._listenerAttached) {
                clearCacheBtn.addEventListener('click', clearAppCache);
                clearCacheBtn._listenerAttached = true;
                console.log('‚úì Clear cache button attached');
            }

            const exportBtn = document.getElementById('export-opml-btn');
            if (exportBtn && !exportBtn._listenerAttached) {
                exportBtn.addEventListener('click', exportOPML);
                exportBtn._listenerAttached = true;
                console.log('‚úì Export OPML button attached');
            }

            const opmlUploadBtn = document.getElementById('opml-upload-btn');
            if (opmlUploadBtn && !opmlUploadBtn._listenerAttached) {
                opmlUploadBtn.addEventListener('click', () => document.getElementById('opml-upload').click());
                opmlUploadBtn._listenerAttached = true;
                console.log('‚úì Opml upload trigger button attached');
            }

            const installFooterBtn = document.getElementById('install-footer-btn');
            if (installFooterBtn && !installFooterBtn._listenerAttached) {
                installFooterBtn.addEventListener('click', triggerInstall);
                installFooterBtn._listenerAttached = true;
                console.log('‚úì Install footer button attached');
            }

            const resetBtn = document.getElementById('reset-feeds-btn');
            if (resetBtn && !resetBtn._listenerAttached) {
                resetBtn.addEventListener('click', resetFeeds);
                resetBtn._listenerAttached = true;
                console.log('‚úì Reset feeds button attached');
            }

            const closeManagerBtn = document.getElementById('close-manager-btn');
            if (closeManagerBtn && !closeManagerBtn._listenerAttached) {
                closeManagerBtn.addEventListener('click', closeManager);
                closeManagerBtn._listenerAttached = true;
                console.log('‚úì Close manager footer button attached');
            }

            const closeInstallBtn = document.getElementById('close-install-instructions-btn');
            if (closeInstallBtn && !closeInstallBtn._listenerAttached) {
                closeInstallBtn.addEventListener('click', () => document.getElementById('install-instructions-modal').classList.remove('active'));
                closeInstallBtn._listenerAttached = true;
                console.log('‚úì Close install instructions (√ó) attached');
            }
            const closeInstallCloseBtn = document.getElementById('close-install-instructions-close-btn');
            if (closeInstallCloseBtn && !closeInstallCloseBtn._listenerAttached) {
                closeInstallCloseBtn.addEventListener('click', () => document.getElementById('install-instructions-modal').classList.remove('active'));
                closeInstallCloseBtn._listenerAttached = true;
                console.log('‚úì Close install instructions (Close) attached');
            }
        }, 100);
    }
    
    // Run fixes after DOM is ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', ensureDomElements);
    } else {
        ensureDomElements();
    }

</script>
</body>
</html>