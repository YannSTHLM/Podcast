<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yann's Favorite Podcasts</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Crect fill='%233498db' width='128' height='128' rx='24'/%3E%3Cpath fill='%23ffffff' d='M64 20c-22.09 0-40 17.91-40 40v32a12 12 0 0 0 12 12h4a8 8 0 0 0 8-8V68a8 8 0 0 0-8-8h-4a12 12 0 0 0-12 12V60c0-19.88 16.12-36 36-36s36 16.12 36 36v12a12 12 0 0 0-12-12h-4a8 8 0 0 0-8 8v28a8 8 0 0 0 8 8h4a12 12 0 0 0 12-12V60c0-22.09-17.91-40-40-40z'/%3E%3C/svg%3E">
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --background-color: #ecf0f1;
            --card-background: #ffffff;
            --text-color: #34495e;
            --border-color: #d6dce2;
            --hover-color: #f7f9fb;
            --success-color: #2ecc71;
            --warning-color: #f39c12;
            --error-color: #e74c3c;
            --transition-speed: 0.25s;
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            min-height: 100vh;
        }

        .container {
            max-width: 1024px;
            width: 100%;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            color: var(--primary-color);
        }

        header h1 {
            margin: 0;
            font-size: clamp(2rem, 3vw, 2.75rem);
        }

        header p {
            margin: 8px 0 0 0;
            font-size: clamp(1rem, 2vw, 1.25rem);
            color: var(--secondary-color);
        }

        .last-updated {
            margin-top: 6px;
            font-size: 0.85rem;
            color: #7f8c8d;
        }

        main {
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        #player-section {
            background-color: var(--card-background);
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(44, 62, 80, 0.08);
        }

        #now-playing h2 {
            margin: 0;
            color: var(--primary-color);
            font-size: 1.5rem;
        }

        #now-playing-description {
            margin: 10px 0 8px;
            font-size: 1rem;
            color: #5d6d7e;
        }

        .now-playing-meta {
            margin: 0;
            font-size: 0.9rem;
            color: #7f8c8d;
        }

        audio {
            width: 100%;
            margin-top: 18px;
            border-radius: 6px;
            background-color: #f8f9fa;
        }

        #status-banner {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            border-radius: 10px;
            border: 1px solid transparent;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.05);
            transition: opacity var(--transition-speed) ease;
        }

        .status-banner--hidden {
            display: none;
        }

        .status-banner__icon {
            font-size: 1.5rem;
        }

        .status-banner__text {
            margin: 0;
            font-size: 0.95rem;
        }

        .status-banner--info {
            background-color: #d1ecf1;
            color: #0c5460;
            border-color: #bee5eb;
        }

        .status-banner--success {
            background-color: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }

        .status-banner--warning {
            background-color: #fff3cd;
            color: #856404;
            border-color: #ffe8a1;
        }

        .status-banner--error {
            background-color: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
        }

        .control-button {
            background-color: var(--primary-color);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: background-color var(--transition-speed) ease, transform var(--transition-speed) ease;
        }

        .control-button:hover,
        .control-button:focus-visible {
            background-color: #1f2d3a;
            transform: translateY(-1px);
        }

        .filter-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: flex-end;
            background-color: var(--card-background);
            border: 1px solid rgba(44, 62, 80, 0.08);
            border-radius: 12px;
            padding: 16px 20px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.06);
        }

        .filter-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            flex: 1 1 220px;
        }

        .filter-group label {
            font-weight: 600;
            color: var(--primary-color);
            font-size: 0.9rem;
        }

        .filter-bar select,
        .filter-bar input[type="search"] {
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            font-size: 0.95rem;
            color: var(--primary-color);
            background-color: #fdfdfd;
            transition: border-color var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
        }

        .filter-bar select:focus-visible,
        .filter-bar input[type="search"]:focus-visible {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.15);
        }

        .results-meta {
            margin: -8px 4px 0;
            text-align: center;
            color: #5d6d7e;
            font-size: 0.95rem;
        }

        #episode-list {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .episode-item {
            background-color: var(--card-background);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: stretch;
            gap: 18px;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            transition: transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease, border-color var(--transition-speed) ease;
        }

        .episode-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
        }

        .episode-item.is-active {
            border-color: var(--secondary-color);
            box-shadow: 0 12px 28px rgba(52, 152, 219, 0.25);
        }

        .episode-details {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .episode-details h3 {
            margin: 0;
            color: var(--primary-color);
            font-size: 1.25rem;
        }

        .episode-summary {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .episode-summary p {
            margin: 0;
            font-size: 0.95rem;
            line-height: 1.6;
            color: #566573;
        }

        .episode-details small {
            display: block;
            color: #7f8c8d;
            font-size: 0.85rem;
        }

        .episode-meta-link {
            color: var(--secondary-color);
            text-decoration: none;
            font-weight: 600;
        }

        .episode-meta-link:hover,
        .episode-meta-link:focus-visible {
            text-decoration: underline;
        }

        .episode-actions {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: flex-end;
            gap: 10px;
            min-width: 150px;
        }

        .play-button,
        .download-button {
            background-color: var(--secondary-color);
            color: #ffffff;
            border: none;
            border-radius: 8px;
            padding: 10px 22px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: background-color var(--transition-speed) ease, transform var(--transition-speed) ease;
        }

        .download-button {
            background-color: #27ae60;
        }

        .play-button:hover,
        .play-button:focus-visible {
            background-color: #2980b9;
            transform: translateY(-1px);
        }

        .download-button:hover,
        .download-button:focus-visible {
            background-color: #229954;
            transform: translateY(-1px);
        }

        button.is-busy {
            cursor: wait;
            opacity: 0.75;
        }

        button:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .loading-message,
        .error-message {
            background-color: var(--card-background);
            border-radius: 12px;
            padding: 32px;
            text-align: center;
            border: 1px dashed var(--border-color);
            color: #5d6d7e;
        }

        .error-message {
            border-style: solid;
            border-color: rgba(231, 76, 60, 0.3);
            color: var(--error-color);
        }

        @media (max-width: 900px) {
            .episode-item {
                flex-direction: column;
                align-items: flex-start;
            }

            .episode-actions {
                flex-direction: row;
                align-items: stretch;
                width: 100%;
            }

            .episode-actions button {
                flex: 1 1 auto;
            }
        }

        @media (max-width: 540px) {
            body {
                padding: 16px;
            }

            .control-button {
                width: 100%;
                text-align: center;
            }

            .episode-actions {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Yann's Favorite Podcasts</h1>
            <p>Financial markets, trading insights & macro trends</p>
            <p id="last-updated-info" class="last-updated" aria-live="polite"></p>
        </header>

        <main>
            <section id="player-section">
                <div id="now-playing">
                    <h2 id="now-playing-title">Select an episode to play</h2>
                    <p id="now-playing-description">Browse the full library of Yann's go-to investing and macro podcasts.</p>
                    <p id="now-playing-meta" class="now-playing-meta" aria-live="polite"></p>
                </div>
                <audio id="audio-player" controls preload="none">
                    Your browser does not support the audio element.
                </audio>
            </section>

            <div id="status-banner" class="status-banner status-banner--hidden" role="status" aria-live="polite">
                <span id="status-icon" class="status-banner__icon" aria-hidden="true">ℹ️</span>
                <p id="status-message" class="status-banner__text"></p>
            </div>

            <section class="controls" aria-label="Podcast library controls">
                <button id="reload-library-btn" class="control-button" type="button">Reload Library</button>
                <button id="reset-filters-btn" class="control-button" type="button">Reset Filters</button>
                <button id="export-opml-btn" class="control-button" type="button">Export OPML</button>
                <button id="import-opml-btn" class="control-button" type="button">Import OPML</button>
                <input type="file" id="opml-file-input" accept=".opml,.xml,application/xml" hidden>
            </section>

            <section class="filter-bar" aria-label="Filter podcasts">
                <div class="filter-group">
                    <label for="podcast-filter">Show</label>
                    <select id="podcast-filter">
                        <option value="all">All podcasts</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label for="search-input">Search</label>
                    <input type="search" id="search-input" placeholder="Search titles or summaries" autocomplete="off">
                </div>
            </section>

            <p id="results-meta" class="results-meta" aria-live="polite"></p>

            <div id="episode-list" role="list">
                <div class="loading-message">
                    <h3>Loading episodes…</h3>
                    <p>Hang tight while we prepare the entire collection.</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const LIBRARY_URL = 'data/podcasts.json';
            const FALLBACK_AUDIO = 'assets/audio/all-in-market-beat.wav';

            const feedHtmlLookup = {
                'all-in-podcast': 'https://www.allinpodcast.co',
                'bloomberg-odd-lots': 'https://www.bloomberg.com/podcasts/odd-lots',
                'cnbc-fast-money': 'https://www.cnbc.com/fast-money/',
                'masters-in-business': 'https://www.bloomberg.com/podcasts/masters-in-business',
                'macro-voices': 'https://macrovoices.com',
                'forward-guidance': 'https://www.blockworks.co/podcast/forward-guidance',
                'chat-with-traders': 'https://chatwithtraders.com',
                'excess-returns': 'https://www.validea.com/excess-returns-podcast',
                'wealthion': 'https://wealthion.com',
                'top-traders-unplugged': 'https://www.toptradersunplugged.com'
            };

            const audioPlayer = document.getElementById('audio-player');
            const nowPlayingTitle = document.getElementById('now-playing-title');
            const nowPlayingDescription = document.getElementById('now-playing-description');
            const nowPlayingMeta = document.getElementById('now-playing-meta');
            const episodeList = document.getElementById('episode-list');
            const lastUpdatedInfo = document.getElementById('last-updated-info');
            const statusBanner = document.getElementById('status-banner');
            const statusMessage = document.getElementById('status-message');
            const statusIcon = document.getElementById('status-icon');
            const reloadButton = document.getElementById('reload-library-btn');
            const resetFiltersButton = document.getElementById('reset-filters-btn');
            const exportButton = document.getElementById('export-opml-btn');
            const importButton = document.getElementById('import-opml-btn');
            const importInput = document.getElementById('opml-file-input');
            const filterSelect = document.getElementById('podcast-filter');
            const searchInput = document.getElementById('search-input');
            const resultsMeta = document.getElementById('results-meta');

            let feeds = [];
            let flattenedEpisodes = [];
            let filteredEpisodes = [];
            let activeFilter = 'all';
            let searchTerm = '';
            let statusTimeoutId = null;
            let currentEpisodeId = null;
            let libraryMeta = { generatedAt: null };

            const statusMap = {
                info: { icon: 'ℹ️', className: 'status-banner--info' },
                success: { icon: '✅', className: 'status-banner--success' },
                warning: { icon: '⚠️', className: 'status-banner--warning' },
                error: { icon: '❌', className: 'status-banner--error' }
            };

            function setStatus(message, type = 'info', timeout = 4000) {
                if (!statusBanner) return;
                const typeClasses = Object.values(statusMap).map(({ className }) => className);
                statusBanner.classList.remove('status-banner--hidden', ...typeClasses);
                const statusConfig = statusMap[type] || statusMap.info;
                statusBanner.classList.add(statusConfig.className);
                statusIcon.textContent = statusConfig.icon;
                statusMessage.textContent = message;

                if (statusTimeoutId) {
                    clearTimeout(statusTimeoutId);
                }

                if (timeout && timeout > 0) {
                    statusTimeoutId = setTimeout(() => {
                        statusBanner.classList.add('status-banner--hidden');
                    }, timeout);
                }
            }

            function clearStatus() {
                if (statusTimeoutId) {
                    clearTimeout(statusTimeoutId);
                    statusTimeoutId = null;
                }
                statusBanner.classList.add('status-banner--hidden');
            }

            function updateLastUpdated(label) {
                if (!lastUpdatedInfo) {
                    return;
                }
                if (libraryMeta.generatedAt) {
                    const formatted = formatTimestamp(libraryMeta.generatedAt);
                    lastUpdatedInfo.textContent = `${label} • Snapshot: ${formatted}`;
                } else {
                    lastUpdatedInfo.textContent = label;
                }
            }

            function formatTimestamp(value) {
                const date = new Date(value);
                if (Number.isNaN(date.getTime())) {
                    return value;
                }
                return `${date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' })} ${date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit' })}`;
            }

            function flattenFeeds(feedsList) {
                return feedsList.flatMap((feed) => {
                    const feedTitle = feed.title || 'Podcast';
                    const feedSlug = feed.slug || feedTitle.toLowerCase().replace(/[^a-z0-9]+/g, '-');
                    const feedUrl = feed.feedUrl || '';
                    const feedCategory = feed.category || '';
                    return (Array.isArray(feed.episodes) ? feed.episodes : []).map((episode) => {
                        const summary = episode.summary || '';
                        const searchText = `${feedTitle} ${episode.title || ''} ${summary}`.toLowerCase();
                        return {
                            ...episode,
                            feedTitle,
                            feedSlug,
                            feedUrl,
                            feedCategory,
                            searchText
                        };
                    });
                });
            }

            function populateFilterOptions(feedsList) {
                const sortedFeeds = [...feedsList].sort((a, b) => a.title.localeCompare(b.title));
                filterSelect.innerHTML = '<option value="all">All podcasts</option>';
                sortedFeeds.forEach((feed) => {
                    const option = document.createElement('option');
                    option.value = feed.slug;
                    option.textContent = feed.title;
                    filterSelect.appendChild(option);
                });
            }

            function applyFilters() {
                filteredEpisodes = flattenedEpisodes.filter((episode) => {
                    const matchesFeed = activeFilter === 'all' || episode.feedSlug === activeFilter;
                    const matchesSearch = !searchTerm || episode.searchText.includes(searchTerm);
                    return matchesFeed && matchesSearch;
                });

                if (filteredEpisodes.length === 0) {
                    episodeList.innerHTML = `
                        <div class="error-message">
                            <h3>No episodes found</h3>
                            <p>Try clearing filters or searching for another topic.</p>
                        </div>
                    `;
                    updateResultsMeta(0);
                    return;
                }

                renderEpisodes(filteredEpisodes);
                updateResultsMeta(filteredEpisodes.length);
            }

            function updateResultsMeta(count) {
                const podcastWord = feeds.length === 1 ? 'podcast' : 'podcasts';
                const parts = [`${count} ${count === 1 ? 'episode' : 'episodes'}`, `${feeds.length} ${podcastWord}`];
                if (activeFilter !== 'all') {
                    const selectedFeed = feeds.find((feed) => feed.slug === activeFilter);
                    if (selectedFeed) {
                        parts.push(selectedFeed.title);
                    }
                }
                if (searchTerm) {
                    parts.push(`“${searchTerm}”`);
                }
                resultsMeta.textContent = parts.join(' · ');
            }

            function renderEpisodes(episodes) {
                episodeList.innerHTML = '';
                const fragment = document.createDocumentFragment();

                episodes.forEach((episode) => {
                    const item = document.createElement('article');
                    item.className = 'episode-item';
                    item.setAttribute('role', 'listitem');
                    item.dataset.episodeId = episode.id;

                    const details = document.createElement('div');
                    details.className = 'episode-details';

                    const titleEl = document.createElement('h3');
                    titleEl.textContent = episode.title || 'Untitled Episode';
                    details.appendChild(titleEl);

                    const summaryEl = document.createElement('div');
                    summaryEl.className = 'episode-summary';
                    populateSummary(summaryEl, episode.summary);
                    details.appendChild(summaryEl);

                    const metaEl = document.createElement('small');
                    const pubDate = new Date(episode.pubDate);
                    const formattedDate = Number.isNaN(pubDate) ? '' : pubDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
                    const timeAgo = formatTimeAgo(pubDate);
                    const metaPieces = [];
                    if (episode.feedTitle) {
                        metaPieces.push(episode.feedTitle);
                    }
                    if (formattedDate) {
                        metaPieces.push(timeAgo ? `${formattedDate} (${timeAgo})` : formattedDate);
                    }
                    if (episode.duration) {
                        metaPieces.push(formatDuration(episode.duration));
                    }
                    metaEl.append(document.createTextNode(metaPieces.join(' • ')));
                    if (episode.feedUrl) {
                        metaEl.append(' • ');
                        const rssLink = document.createElement('a');
                        rssLink.href = episode.feedUrl;
                        rssLink.target = '_blank';
                        rssLink.rel = 'noopener';
                        rssLink.className = 'episode-meta-link';
                        rssLink.textContent = 'RSS';
                        metaEl.appendChild(rssLink);
                    }
                    details.appendChild(metaEl);

                    const actions = document.createElement('div');
                    actions.className = 'episode-actions';

                    const playButton = document.createElement('button');
                    playButton.type = 'button';
                    playButton.className = 'play-button';
                    playButton.dataset.id = episode.id;
                    playButton.textContent = currentEpisodeId === episode.id ? 'Playing…' : 'Play';

                    const downloadButton = document.createElement('button');
                    downloadButton.type = 'button';
                    downloadButton.className = 'download-button';
                    downloadButton.dataset.id = episode.id;
                    downloadButton.dataset.src = episode.audioUrl;
                    downloadButton.dataset.title = episode.title || 'Podcast Episode';
                    downloadButton.textContent = 'Download';

                    actions.append(playButton, downloadButton);
                    item.append(details, actions);
                    fragment.append(item);
                });

                episodeList.append(fragment);
            }

            function populateSummary(container, summary) {
                container.innerHTML = '';
                if (!summary) {
                    const paragraph = document.createElement('p');
                    paragraph.textContent = 'No description available for this episode yet.';
                    container.appendChild(paragraph);
                    return;
                }
                const paragraphs = summary.split(/\n{2,}|(?<=\.)(?:\s{2,}|\n)/);
                paragraphs.forEach((chunk) => {
                    const text = chunk.trim();
                    if (!text) return;
                    const paragraph = document.createElement('p');
                    paragraph.textContent = text;
                    container.appendChild(paragraph);
                });
            }

            function formatDuration(seconds) {
                if (typeof seconds !== 'number' || Number.isNaN(seconds) || seconds <= 0) {
                    return '';
                }
                const hrs = Math.floor(seconds / 3600);
                const mins = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const parts = [];
                if (hrs) {
                    parts.push(`${hrs}h`);
                }
                parts.push(`${mins.toString().padStart(2, '0')}m`);
                parts.push(`${secs.toString().padStart(2, '0')}s`);
                return parts.join(' ');
            }

            function formatTimeAgo(date) {
                if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
                    return '';
                }
                const diffMs = Date.now() - date.getTime();
                const suffix = diffMs >= 0 ? 'ago' : 'from now';
                const absDiff = Math.abs(diffMs);

                const minute = 60 * 1000;
                const hour = minute * 60;
                const day = hour * 24;
                const month = day * 30;
                const year = day * 365;

                const units = [
                    { value: year, label: 'year' },
                    { value: month, label: 'month' },
                    { value: day, label: 'day' },
                    { value: hour, label: 'hour' },
                    { value: minute, label: 'minute' }
                ];

                for (const unit of units) {
                    if (absDiff >= unit.value || unit.label === 'minute') {
                        const count = Math.max(1, Math.round(absDiff / unit.value));
                        return `${count} ${unit.label}${count !== 1 ? 's' : ''} ${suffix}`;
                    }
                }

                return '';
            }

            function handlePlayButtonClick(button) {
                const episodeId = button.dataset.id;
                const episode = flattenedEpisodes.find((item) => item.id === episodeId);
                if (!episode) {
                    setStatus('Unable to find that episode.', 'error');
                    return;
                }

                const previousActive = episodeList.querySelector('.episode-item.is-active');
                if (previousActive) {
                    previousActive.classList.remove('is-active');
                }
                button.closest('.episode-item')?.classList.add('is-active');

                currentEpisodeId = episode.id;
                const playButtons = episodeList.querySelectorAll('.play-button');
                playButtons.forEach((btn) => {
                    btn.textContent = btn.dataset.id === episode.id ? 'Playing…' : 'Play';
                });

                delete audioPlayer.dataset.fallbackUsed;
                audioPlayer.pause();
                audioPlayer.src = episode.audioUrl;
                audioPlayer.load();
                audioPlayer.play()
                    .then(() => {
                        updateNowPlaying(episode);
                    })
                    .catch((error) => {
                        console.error('Playback failed', error);
                        setStatus('Playback was blocked. Press play again to continue.', 'warning');
                    });
            }

            function updateNowPlaying(episode) {
                nowPlayingTitle.textContent = episode.title || 'Now Playing';
                nowPlayingDescription.textContent = episode.summary || 'Enjoy the episode!';
                const pubDate = new Date(episode.pubDate);
                const formattedDate = Number.isNaN(pubDate) ? '' : pubDate.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
                const durationDisplay = formatDuration(episode.duration);
                const metaParts = [];
                if (episode.feedTitle) {
                    metaParts.push(episode.feedTitle);
                }
                if (formattedDate) {
                    metaParts.push(formattedDate);
                }
                if (durationDisplay) {
                    metaParts.push(durationDisplay);
                }
                nowPlayingMeta.textContent = metaParts.join(' • ');
            }

            async function downloadEpisode(audioUrl, title, button) {
                if (!audioUrl || !button) {
                    setStatus('Episode audio not available for download.', 'error');
                    return;
                }

                button.disabled = true;
                button.classList.add('is-busy');
                const originalText = button.textContent;
                button.textContent = 'Preparing…';

                try {
                    const response = await fetch(audioUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const blob = await response.blob();
                    const filename = createSafeFileName(title, blob.type, audioUrl);

                    if ('showSaveFilePicker' in window) {
                        try {
                            const extension = filename.split('.').pop() || 'audio';
                            const fileHandle = await window.showSaveFilePicker({
                                suggestedName: filename,
                                types: [
                                    {
                                        description: 'Audio file',
                                        accept: { [blob.type || 'audio/*']: [`.${extension}`] }
                                    }
                                ]
                            });
                            const writableStream = await fileHandle.createWritable();
                            await writableStream.write(blob);
                            await writableStream.close();
                        } catch (pickerError) {
                            if (pickerError.name === 'AbortError') {
                                setStatus('Download cancelled.', 'warning');
                                return;
                            }
                            throw pickerError;
                        }
                    } else {
                        const objectUrl = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = objectUrl;
                        link.download = filename;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(objectUrl);
                    }

                    button.textContent = 'Saved!';
                    setStatus(`Downloaded "${title}".`, 'success');
                } catch (error) {
                    console.warn('Download failed, opening fallback link.', error);
                    const fallbackLink = document.createElement('a');
                    fallbackLink.href = audioUrl;
                    fallbackLink.target = '_blank';
                    fallbackLink.rel = 'noopener';
                    document.body.appendChild(fallbackLink);
                    fallbackLink.click();
                    document.body.removeChild(fallbackLink);
                    setStatus('Opened the audio in a new tab. Use your browser menu to save it locally.', 'warning', 6000);
                } finally {
                    setTimeout(() => {
                        button.disabled = false;
                        button.classList.remove('is-busy');
                        button.textContent = originalText;
                    }, 1500);
                }
            }

            function createSafeFileName(title, mimeType = '', sourceUrl = '') {
                const base = (title || 'episode')
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, '_')
                    .replace(/^_+|_+$/g, '') || 'episode';

                const mime = (mimeType || '').toLowerCase();
                const mimeMap = {
                    'audio/mpeg': 'mp3',
                    'audio/mp3': 'mp3',
                    'audio/x-mpeg': 'mp3',
                    'audio/aac': 'aac',
                    'audio/wav': 'wav',
                    'audio/x-wav': 'wav',
                    'audio/ogg': 'ogg',
                    'audio/webm': 'webm',
                    'audio/flac': 'flac'
                };

                let extension = mimeMap[mime];

                if (!extension && sourceUrl) {
                    const match = sourceUrl.split('#')[0].split('?')[0].match(/\.([a-z0-9]+)$/i);
                    if (match) {
                        extension = match[1].toLowerCase();
                    }
                }

                if (!extension || extension.length > 5) {
                    extension = 'audio';
                }

                return `${base}.${extension}`;
            }

            function buildOPML(feedsList) {
                const header = `<?xml version="1.0" encoding="UTF-8"?>\n<opml version="2.0">\n<head>\n<title>Yann's Favorite Podcasts</title>\n</head>\n<body>`;
                const outlines = feedsList
                    .filter((feed) => feed.feedUrl)
                    .map((feed) => {
                        const htmlUrl = feedHtmlLookup[feed.slug] || '';
                        return `  <outline text="${escapeXML(feed.title)}" title="${escapeXML(feed.title)}" type="rss" xmlUrl="${escapeXML(feed.feedUrl)}"${htmlUrl ? ` htmlUrl="${escapeXML(htmlUrl)}"` : ''}/>`;
                    })
                    .join('\n');
                const footer = '\n</body>\n</opml>';
                return `${header}\n${outlines}${footer}`;
            }

            function escapeXML(value = '') {
                return value
                    .replace(/&/g, '&amp;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
            }

            function parseOPMLToFeeds(opmlText) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(opmlText, 'text/xml');
                if (xmlDoc.querySelector('parsererror')) {
                    throw new Error('Invalid OPML');
                }
                const outlines = Array.from(xmlDoc.querySelectorAll('outline[type="rss"]'));
                return outlines.map((outline) => ({
                    title: outline.getAttribute('title') || outline.getAttribute('text') || 'Podcast feed',
                    xmlUrl: outline.getAttribute('xmlUrl') || outline.getAttribute('url') || '',
                    htmlUrl: outline.getAttribute('htmlUrl') || ''
                })).filter((feed) => Boolean(feed.xmlUrl));
            }

            async function loadLibrary({ showStatus = true } = {}) {
                try {
                    if (showStatus) {
                        setStatus('Loading Yann’s podcast library…', 'info', 0);
                    }
                    const response = await fetch(LIBRARY_URL, { cache: 'no-store' });
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    const data = await response.json();
                    feeds = Array.isArray(data.feeds) ? data.feeds : [];
                    libraryMeta.generatedAt = data.generatedAt || null;
                    flattenedEpisodes = flattenFeeds(feeds);
                    populateFilterOptions(feeds);
                    activeFilter = 'all';
                    searchTerm = '';
                    filterSelect.value = 'all';
                    searchInput.value = '';

                    if (flattenedEpisodes.length === 0) {
                        episodeList.innerHTML = `
                            <div class="error-message">
                                <h3>No episodes available</h3>
                                <p>Add shows to <code>data/podcasts.json</code> to populate the library.</p>
                            </div>
                        `;
                        updateResultsMeta(0);
                        setStatus('Library loaded but contains no episodes yet.', 'warning', 6000);
                    } else {
                        applyFilters();
                        setStatus(`Loaded ${flattenedEpisodes.length} episodes across ${feeds.length} podcasts.`, 'success');
                    }

                    updateLastUpdated('Library refreshed');
                } catch (error) {
                    console.error('Failed to load library', error);
                    episodeList.innerHTML = `
                        <div class="error-message">
                            <h3>Unable to load library</h3>
                            <p>Please check that <code>${LIBRARY_URL}</code> exists and try again.</p>
                        </div>
                    `;
                    updateLastUpdated('Library unavailable');
                    setStatus('Unable to load the episode library. Please refresh and try again.', 'error', 6000);
                }
            }

            reloadButton.addEventListener('click', () => {
                loadLibrary({ showStatus: true });
            });

            resetFiltersButton.addEventListener('click', () => {
                activeFilter = 'all';
                searchTerm = '';
                filterSelect.value = 'all';
                searchInput.value = '';
                applyFilters();
                setStatus('Filters cleared.', 'info');
            });

            filterSelect.addEventListener('change', (event) => {
                activeFilter = event.target.value;
                applyFilters();
            });

            searchInput.addEventListener('input', (event) => {
                searchTerm = event.target.value.trim().toLowerCase();
                applyFilters();
            });

            episodeList.addEventListener('click', (event) => {
                const playButton = event.target.closest('.play-button');
                if (playButton) {
                    handlePlayButtonClick(playButton);
                    return;
                }

                const downloadButton = event.target.closest('.download-button');
                if (downloadButton) {
                    const episodeId = downloadButton.dataset.id;
                    const episode = flattenedEpisodes.find((item) => item.id === episodeId);
                    if (episode) {
                        downloadEpisode(episode.audioUrl, episode.title || 'Podcast Episode', downloadButton);
                    } else {
                        setStatus('Unable to find that episode.', 'error');
                    }
                }
            });

            exportButton.addEventListener('click', () => {
                const opmlContent = buildOPML(feeds);
                const blob = new Blob([opmlContent], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'yanns-favorite-podcasts.opml';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                setStatus('Exported OPML file successfully.', 'success');
            });

            importButton.addEventListener('click', () => importInput.click());

            importInput.addEventListener('change', (event) => {
                const file = event.target.files?.[0];
                if (!file) {
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const contents = e.target?.result;
                        if (typeof contents !== 'string') {
                            throw new Error('Invalid file contents');
                        }
                        const importedFeeds = parseOPMLToFeeds(contents);
                        if (importedFeeds.length === 0) {
                            setStatus('No valid RSS feeds were found in that OPML file.', 'warning', 6000);
                            return;
                        }
                        setStatus(`Imported ${importedFeeds.length} feed URLs. Add them to data/podcasts.json to include them here.`, 'success', 7000);
                    } catch (error) {
                        console.error('Failed to import OPML', error);
                        setStatus('Failed to parse the OPML file.', 'error', 6000);
                    }
                };
                reader.readAsText(file);
                importInput.value = '';
            });

            audioPlayer.addEventListener('error', () => {
                if (!audioPlayer.dataset.fallbackUsed) {
                    audioPlayer.dataset.fallbackUsed = 'true';
                    audioPlayer.src = FALLBACK_AUDIO;
                    audioPlayer.load();
                    audioPlayer.play().catch(() => {});
                    setStatus('Episode audio could not be loaded. Playing fallback tone instead.', 'warning', 6000);
                } else {
                    setStatus('Audio playback failed. Try another episode.', 'error', 6000);
                }
            });

            loadLibrary({ showStatus: false });
        });
    </script>
</body>
</html>
